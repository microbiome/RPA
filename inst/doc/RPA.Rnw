%\VignetteIndexEntry{RPA}
%The above line is needed to remove a warning in R CMD check
\documentclass[12pt]{article}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{hyperref}
%\usepackage[authoryear,round]{natbib}
\usepackage{Sweave}

\textwidth=6.2in
\textheight=8.5in
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}

\def\muj{\mathbf{\mu}_j}
\def\mujs{\{\mathbf{\mu}_j\}}

\def\s{\{\mathbf{s}\}}
\def\st{\mathbf{s}^t}
\def\sj{\mathbf{s}_j}
\def\sij{s_{ij}}
\def\sjs{\mathbf{s}_{j=1}^J}
\def\sjt{\mathbf{s}_j^t}
\def\stj{s_{tj}}
\def\scj{s_{cj}}
\def\stjs{\{s_{tj}\}_t}
\def\sjI{\mathbf{s}_j^1}
\def\sjT{\mathbf{s}_j^T}

\def\m{\mathbf{m}}
\def\mj{\mathbf{m}_j}
\def\mjs{\{\mathbf{m}_j\}}
\def\mtj{m_{tj}}

\def\gj{\{\mathbf{g}_j\}}
\def\gi{g_i}
\def\gt{g_t}
\def\gc{g_c}
\def\g{\mathbf{g}}

\def\d{\mathbf{d}}
\def\dt{d_t}
\def\djt{\mathbf{d}_j^t}
\def\djr{\mathbf{s}_{j}}

\def\TauSq{\boldsymbol{\tau}^2}
\def\tauj{\mathbf{\tau}_j}
\def\taus{\{\tau_j^2\}}
\def\taujSq{\mathbf{\tau}_j^2}
\def\tauOneSq{\mathbf{\tau}_1^2}
\def\tauPSq{\mathbf{\tau}_J^2}

\def\epsilonj{\varepsilon_j}
\def\epsilonij{\mathbf{\varepsilon}_{ij}}
\def\epsiloncj{\varepsilon_{cj}}
\def\epsilontj{\varepsilon_{tj}}
\def\epsilontjs{\{\varepsilon_{tj}\}_t}
\def\epsiloncjs{\{\varepsilon_{cj}\}_j}
\def\Epsilonj{\boldsymbol{\varepsilon}_j}
\def\Epsiloncj{\boldsymbol{\varepsilon}_{cj}}

\def\alphaj{\alpha_j}
\def\betaj{\beta_j}
\def\alphahatj{\hat{\alpha}_j}
\def\betahatj{\hat{\beta}_j}

\def\zi{z_i}
\def\j{\mathbf{j}}
\def\sigmaj{\sigma_j}
\def\lambdaj{\lambda_j}

\author{Leo Lahti\footnote{http://www.iki.fi/Leo.Lahti}\\University of Helsinki\\leo.lahti@iki.fi}
  
\begin{document}
\title{Robust Probabilistic Averaging for probe reliability analysis and preprocessing on short
  oligonucleotide arrays}

\maketitle 

\section{Introduction}
 
\Rpackage{RPA} (Robust Probabilistic
Averaging)\footnote{\url{http://bioconductor.org/packages/release/bioc/html/RPA.html}}
provides tools for probe reliability analysis and gene expression
preprocessing for (Affymetrix) short oligonucleotide arrays. It can
also be used more generally to summarize multivariate observations
that target the same objects with varying degree of reliability.

RPA can be used for probe-level analysis of microarray data. The
method provides explicit data-driven estimates of probe performance,
i.e. affinity and probe-specific noise level. Affinities are taken
into account in summarizing the probes and noisy probes are
downweighted, which yields more accurate estimates of gene
expression. The model can reveal noisy probes independently of the
error source noise; noise estimates have been validated by comparisons
to known probe-level error sources \cite{Lahti11}. RPA has been
shown to outperform other popular preprocessing methods in
cross-platform studies and spike-in data sets (see below). The
probabilistic formulation allows also incorporation of prior
information concerning probe reliability into gene expression analysis
\cite{Lahti11}.


\section{Preprocessing gene expression data with RPA}

RPA provides a wrapper ('rpa') for convenient preprocessing of
Affymetrix arrays. Alternative CDF environments are also supported
(see help(rpa) for details). Here is a preprocessing example with an
example data set:

<<rpa, results = hide, eval = FALSE>>=
library(affydata)
data(Dilution)
eset <- rpa(Dilution)
@

The input is an AffyBatch object. CEL files can be read in as
affybatch with the ReadAffy function of the affy package. The output
is an ExpressionSet object, which allows downstream analysis of the
results using standard R/BioC tools for gene expression data.

\subsection{AffyComp results}

RPA was systematically compared to a number of other preprocessing
methods through the AffyComp
website\footnote{http://affycomp.jhsph.edu/AFFY2/TABLES.hgu/0.html as
of March 13, 2011} that provides the standard for comparing
alternative preprocessing methods with various performance statistics
\cite{Cope04}. Measured by the average ranking of the methods in the
different tests (14 tests), RPA was ranked as 1/65 and 4/95 with hgu95
and hgu133 spike-in data sets, respectively (March 13, 2011). The
highest average ranks on hgu133 data were obtained by the three 'NLF'
methods but results for these methods were not available for hgu95
(the NLF95 which has a similar name ranked 6/95). This confirms that
RPA has the best generalizability across different data sets and has
superior preprocessing performance in short oligonucleotide array
studies.  However, RPA does not only provide excellent preprocessing
performance, it also provides explicit quantitative estimates of
uncertainty in individual probes.

\section{Probe reliability analysis}

RPA operates on affybatch objects \cite{Gautier04a}. An affybatch
contains the probe-level data of Affymetrix arrays. Our toy examples
use the \Robject{Dilution} dataset provided by \Rpackage{affydata}
package. Load example data (the 'Dilution' affybatch):

<<startchunk,results=hide>>=
require(affy)
require(affydata)
data(Dilution)
@

{\it RPA.pointestimate} is the main function. Let us perform the
analysis for particular probesets in the Dilution data (the whole data
set will be analyzed by default if 'sets' is not given).

<<RPA.pointestimate, results = hide>>=
require(RPA)
sets <- geneNames(Dilution)[1:2]
rpa.results <- RPA.pointestimate(Dilution, sets)
@

The 'rpa2eset' function can be used to coerce the probeset-level
expression estimates into an ExpressionSet object.  The results for a
particular probeset can be visualized with

<<visu, fig = FALSE, echo = TRUE, print = FALSE, results = hide, eval = FALSE>>=
plot(rpa.results, set = "1000_at", plots = "all")
#plot(rpa.results, set = set, plots = "data")
@

The output is shown in Figure \ref{fig:illustration}. See
help('rpa.plot') for details.

\begin{figure}[htbp]
\begin{center}
<<barplots, fig = TRUE, echo = FALSE, print = FALSE, results = hide>>=
dat <- plot(rpa.results, set = "1000_at", plots = "all")
@
\caption{Estimated probe affinities, probe-specific noise level (standard deviation) and probeset-level summary estimate for an example probe set.}
\label{fig:illustration}
\end{center}
\end{figure}


\subsection{Estimating probe-specific noise and probe reliability}

RPA estimates the noise level of each individual probe through the
probe-specific variance parameter (\(\taujSq\)). These can be obtained
with

<<noise,results=hide>>=
noise <- get.probe.noise.estimates(rpa.results)
@ 

The higher the variance, the more noisy the probe. Inverse of the
variance, \(\frac{1}{\taujSq}\), can be used to quantitate probe
reliability. Note that the relative weight of a probe within probeset
is determined by the relative noise of the probe with respect to the
other probes in the same probeset. Comparison of probe-specific
variances across probesets may benefit from normalization of this
effect.  The get.probe.noise.estimates function can optionally provide
normalized versions of the noise estimates.


\subsection{Setting probe-specific priors}

Prior information of probe reliability can be set by tuning the shape
(\(\alpha\)) and scale (\(\beta\)) parameters of the inverse Gamma
distribution, which is the conjugate prior for the variances. Set
priors for a particular probeset. If the 'priors' parameter is not
given, non-informative priors will be given for the other probesets:

<<setpriors, results = hide>>=
alpha <- beta <- rep(1, 16)
probe.index <- 5
alpha[[probe.index]] <- 3
beta[[probe.index]] <- 1
priors <- set.priors(Dilution, set = "1000_at", alpha, beta)
@

Run RPA with priors:

<<pe, results=hide, eval = FALSE>>=
rpa.results <- RPA.pointestimate(Dilution, sets, priors = priors)
@                                  

\subsection{General usage}

Robust Probabilistic Averaging can be used to summarize any
multivariate observations concerning the same object and having
varying (Gaussian) affinities and noise levels, see function rpa.fit:

<<iter, results=hide, eval = FALSE>>=
res <- rpa.fit(S)
@


\section{The probabilistic model}

\subsection{Relation to other probe-level models}

RPA differs from other popular preprocessing algorithms in two key
respects.  First, it utilizes probe-level estimates of differential
expression; these are calculated {\it before} probeset-level
summarization, which avoids certain probe-level effects that obscure
the results in other preprocessing methods where probes with various
affinities and contamination levels are combined into a probeset-level
summary prior to differential expression analyses. In particular, our
procedure avoids the modeling of unidentifiable probe affinities,
which is the key probe-specific parameter in many preprocessing
methods. Second, RPA provides tools for investigating the reliability
of individual probes in terms of a probe-specific variance. This can
be used in microarray design and in confirming the end results of a
microarray study. These properties distinguish RPA from other
probe-level preprocessing methods such as dChip's MBEI
\cite{Li01pnas}, RMA \cite{Irizarry03rma}, or FARMS
\cite{Hochreiter06}.

\subsection{Summary of RPA model}

\subsubsection{Background correction and normalization}

The probe-level data is background corrected, normalized, and
log2-transformed before the analysis. By default, RPA uses the
background correction model of RMA \cite{Irizarry03} and quantile
normalization \cite{Bolstad03}. Our implementation utilizes the
\Rpackage{affy} package \cite{Gautier04a} to handle probe-level data.
For details about short oligonucleotide arrays and the design of the
Affymetrix GeneChip arrays, see the Affymetrix MAS manual
\cite{affy5}. 

\subsubsection{Probe reliability estimation and summarization}

The RPA algorithm is used to obtain probeset-level summaries for gene
expression and to estimate probe-specific noise. RPA assumes a
Gaussian model for probe effects.  Let us consider a probe set
targeted at measuring the expression level of target transcript
\(g\). Probe-level observation \(\sij\) of probe \(j\) on array \(i\)
is modeled as a sum of the true expression signal (common for all
probes in the probeset), and probe-specific Gaussian noise: \(\sij =
\gi + \muj + \epsilonij\). The stochastic noise component is
probe-specific, distributed as \(\epsilonij \sim N(0,\taujSq)\). The
variance parameters \(\taus\) are of interest in probe reliability
analysis; the inverse variance \(1/\taujSq\) can be used to measure of
probe reliability (see get.probe.noise.estimates function).

The mean parameter \(\muj\) of the noise model describes systematic
probe affinity effect, which is unidentifiable. These parameters
cancel out in RPA when the signal log-ratio between a user-specified
'reference' array and the remaining arrays is calculated at probe
level: the differential expression signal between arrays \(t = \{1,
\dots, T\} \) and the reference array \(c\) for probe \(j\) is given
by \(\mtj = \stj - \scj = \gt - \gc + \epsilontj - \epsiloncj = \dt +
\epsilontj - \epsiloncj\). In vector notation the differential
expression profile of probe \(j\) across the arrays can be written as
\(\mj = \d + \Epsilonj\). In practice, \(\d\) and the probe-specific
variances \(\{\tau_j\}_{j=1}^P\) for the \(P\) probes within the
probeset are estimated simultaneously based on the probabilistic
model.

With large sample sizes the solution will converge to estimating the
mean of the probe-level observations weighted by probe reliability.
The algorithm is robust to choice of the reference array since the
reference effect is marginalized out in the probabilistic treatment;
our experiments confirm that the probe-level noise estimates are not
affected by the choice of the reference array.

\subsubsection{Probe affinity estimation}

Probe affinity terms and the original signal level are estimated after
summarizing the probe-level differential gene expression estimates.
First an estimate of the absolute signal level is calculated based on
particular modeling assumptions. Then probe-specific affinities are
calculated by comparing each probe to the probeset-level signal
estimate.

Let us write the probe-level observation in terms of differential
expression signal, absolute signal level, and stochastic noise as
\(\sj = \d + \mu + \varepsilon\), where \(\mu\) is a scalar (vector
with identical elements). This will indicate how much probe-level
observation deviates from the estimated signal shape \(\d\).  This can
be decomposed as \(\mu = \mu_{real} + \mu_{probe}\), where
\(\mu_{real}\) describes the 'real' signal level, common for all
probes and \(\mu_{probe}\) describes probe affinity effect. Let us
assume that \(\mu_{probe} ~ N(0, \sigma^2_{probe})\).  This encodes
the assumption that in general the affinity effect of each probe tends
to be close to zero.  Then ML estimates of \(\mu_{real}\) and
\(\mu_{probe}\) are calculated based on these particular assumptions.
This part of the algorithm has not been defined in full probabilistic
terms, we are only providing the point estimates.

If an identical prior is used for all probes in affinity estimation
then \(\mu_{real}\) is estimated as the average of the probe effects
\(\mu\) and the probe-specific affinities \(\mu_{probe}\) will sum to
exactly zero ('zeromean' option). This is analogous to the model used
in RMA, which uses medianpolish algorithm to fit this assumption. In
contrast to our model the stochastic probe effects are not
probe-specific in RMA.  We suggest an alternative approach where
probes are weighted during affinity estimation ('rpa' option).  While
\(\sigma^2\) estimated by RPA measures stochastic noise, not the
affinity effect, we utilize them to give a heuristic weigh for the
probes in affinity estimation according to how much they contribute to
the overall signal shape. Intuitively, probes that have little effect
on the signal shape (i.e. are very noisy and likely to be contaminated
by many unrelated signals) should also contribute less to the absolute
signal estimate. The probe affinities are expected to sum to zero but
the model allows some flexibility.


\section{Citing RPA}

Please cite \cite{Lahti11} when using the package.

\section{Details}

This document was written using:

<<details>>=
sessionInfo()
@

\bibliographystyle{abbrv}
\bibliography{RPA}

\end{document}

%To investigate a particular probeset, preprocess data before the
%analysis:
%
%<<Smat,results=hide, eval = FALSE>>=
%prep <- RPA.preprocess(Dilution, cind = 1)
%@
%
%Pick probe-level data for a probe set (arrays x probes matrix):
%
%<<pick, results=hide, eval = FALSE>>=
%probe.indices <- prep$set.inds[["1000_at"]]
%S <- prep$q[probe.indices, ]
%@
%
%Estimate probeset-level summary and probe-specific variance and
%affinity terms:


